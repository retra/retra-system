// lib.dhtml 1.5.4
// requires: lib.elm, lib.evt, lib.vector
// 
// protected by creative commons deed
// under the following conditions: Attribution, Share Alike
// http://creativecommons.org/licenses/by-sa/2.5/
// 
// dhtml positioning and calculations. Replaces sc.dhtml
//
// WARNING
// in MSIE, all positioned elements MUST have layout 
// (see http://www.satzansatz.de/cssd/onhavinglayout.html)
// or the absolute positioning will fail

var lib = lib || {};
lib.dhtml = lib.dhtml || {};




lib.dhtml.name = "lib.dhtml";




lib.dhtml.setAbsolute = function (elm) {
	// changes the positioning of elm to absolute.
	elm.style.margin = "0"; // prevent positioning bugs
	elm.style.position = "absolute";
	return true;
};

lib.dhtml.setStatic = function (elm) {
	// changes the positioning of elm to static
	elm.style.position = "static";
	return true;
};

lib.dhtml.getPos = function (elm) {
	// from http://www.quirksmode.org/js/findpos.html
	// many thanks to Peter Paul Koch
	// element's position relative to page
	var offsetModifier = lib.dhtml._getOffsetModifier(elm);
	var x = elm.offsetLeft + offsetModifier[0];
	var y = elm.offsetTop + offsetModifier[1];
	return [x, y];
};

lib.dhtml.fixPos = function (elm) {
	// sets the position if not set explicitly
	// use this before setting the position to absolute - element will remain on it's place
	lib.dhtml.setPos(elm, lib.dhtml.getPos(elm));
	return true;
};

lib.dhtml.setPos = function (elm, newPos) {
	// moves obj to specified coordinates
	var offsetModifier = lib.dhtml._getOffsetModifier(elm);
	var pos = lib.vector.subtract(newPos, offsetModifier);
	elm.style.left = pos[0] + "px";
	elm.style.top  = pos[1] + "px";
	return true;
};

lib.dhtml.changePos = function (elm, movementVector) {
	var pos = lib.dhtml.getPos(elm);
	var newPos = lib.vector.add(pos, movementVector);
	lib.dhtml.setPos(elm, newPos);
	return true;
};

lib.dhtml.getMouseEvtPos = function (e) {
	// returns the position of the event generated by mouse in absolute coordinates
	var pos = lib.evt.getMousePosition(e);
	return [pos.x, pos.y];
};

lib.dhtml.getRelPos = function (elm, refElm) {
	// returns position of elm relative to position of refElm
	var pos = lib.dhtml.getPos(elm);
	var refPos = lib.dhtml.getPos(refElm);
	var relPos = lib.vector.getDirection(refPos, pos);
	return relPos;
};

lib.dhtml.getSize = function (elm) {
	// returns the size of the block element
	// elements with display:none return incorrect size, this shall help
	var vis = null;
	if (elm.style.display == "none") {
		vis = elm.style.visibility;
		elm.style.visibility = "hidden";
		elm.style.display = "";
	}
	
	var w = elm.offsetWidth;
	var h = elm.offsetHeight;
	
	// return to the original state
	if (vis !== null) {
		elm.style.display = "none";
		elm.style.visibility = vis;
	}
	return [w, h];
};

lib.dhtml.fixSize = function (elm) {
	// sets the size if not set explicitly
	// TODO: what if the element has borders or paddings?
	lib.dhtml.setSize(elm, lib.dhtml.getSize(elm));
	return true;
};

lib.dhtml.setSize = function (elm, newSize) {
	// sets new size of the object
//	var actualVisibility = elm.style.visibility;
//	elm.style.visibility = "hidden";
	// standard resize
	elm.style.width = newSize[0] + "px";
	elm.style.height = newSize[1] + "px";
	
/*	// when the element has got the borders or paddings, the size may be wrong
	var realSize = lib.dhtml.getSize(elm);
	
	if ((realSize[0] != newSize[0]) || (realSize[1] != newSize[1])) {
		elm.style.width  = "0px";
		elm.style.height = "0px";
		
		elm.style.width = (2*newSize[0] - realSize[0]) + "px";
		elm.style.height = (2*newSize[1] - realSize[1]) + "px";
	}
	elm.style.visibility = actualVisibility;
*/
	return true;
};

lib.dhtml.changeSize = function (elm, sizeModifier) {
	var size = lib.dhtml.getSize(elm);
	var newSize = lib.vector.add(size, sizeModifier);
	lib.dhtml.setSize(elm, newSize);
	return true;
};

lib.dhtml.isOver = function (elm, point) {
	// returns true if point [x,y] is over the object obj
	var x = point[0];
	var y = point[1];
	var pos = lib.dhtml.getPos(elm);
	var size = lib.dhtml.getSize(elm);
	
	var xMin = pos[0];
	if (x < xMin) { return false; }
	var xMax = xMin + size[0];
	if (x > xMax) { return false; }
	var yMin = pos[1];
	if (y < yMin) { return false; }
	var yMax = yMin + size[1];
	if (y > yMax) { return false; }
	return true;
};

lib.dhtml.getViewPos = function () {
	// get viewport position
	var x = 0;
	var y = 0;
	if( typeof window.pageXOffset == "number" ) {
	// Netscape compliant
		x = window.pageXOffset;
		y = window.pageYOffset;
	} else if ( document.body && ( document.body.scrollLeft || document.body.scrollTop ) ) {
		//DOM compliant
		x = document.body.scrollLeft;
		y = document.body.scrollTop;
	} else if ( document.documentElement && ( document.documentElement.scrollLeft || document.documentElement.scrollTop ) ) {
		//IE6 standards compliant mode
		x = document.documentElement.scrollLeft;
		y = document.documentElement.scrollTop;
	}
	return [ x, y ];
};

lib.dhtml.getViewSize = function () {
	// returns the size of the viewport
	// by pixy, http://www.pixy.cz/blogg/clanky/js-rozmery-okna.html
	var winW = null;
	var winH = null;
	if (window.innerWidth) { // NN4, Opera, Mozilla
		winW = window.innerWidth;
		winH = window.innerHeight;
	} else if (document.documentElement && document.documentElement.clientWidth) { // MSIE6 std. mode
		winW = document.documentElement.clientWidth;
		winH = document.documentElement.clientHeight;
	} else if (document.body && document.body.clientWidth) { // older MSIE + MSIE6 in quirks mode
		winW = document.body.clientWidth;
		winH = document.body.clientHeight;
	}
	return [winW, winH];
};

lib.dhtml.getPageSize = function () {
	// returns the page size
	// Core code from quirksmode.org
	// edit for Firefox by pHaez
	// taken from Lokesh Dhakar - http://www.huddletogether.com
	
	var pageW = null;
	var pageH = null;
	
	var xScroll, yScroll;
	if (window.innerWidth && window.scrollMaxX) {
		xScroll = window.innerWidth + window.scrollMaxX;
		yScroll = window.innerHeight + window.scrollMaxY;
	} else if (document.body.scrollWidth > document.body.offsetWidth){ // all but Explorer Mac
		xScroll = document.body.scrollWidth;
		yScroll = document.body.scrollHeight;
	} else { // Explorer Mac...would also work in Explorer 6 Strict, Mozilla and Safari
		xScroll = document.body.offsetWidth;
		yScroll = document.body.offsetHeight;
	}
	
	var viewSize = lib.dhtml.getViewSize();
	
	if (xScroll < viewSize[0]) { // for small pages with total width less then width of the viewport
		pageW = viewSize[0];
	} else {
		pageW = xScroll;
	}
	
	if (yScroll < viewSize[1]) { // for small pages with total width less then width of the viewport
		pageH = viewSize[1];
	} else {
		pageH = yScroll;
	}
	return [pageW, pageH];
};

lib.dhtml.isBlockOver = function (elmA, elmB) {
	// returns true if elm1 and elm2 overlap each other
	var result = true;
	var lhA = lib.dhtml.getPos(elmA);
	var sizeA = lib.dhtml.getSize(elmA);
	var pdA = [lhA[0] + sizeA[0], lhA[1] + sizeA[1]];
	var lhB = lib.dhtml.getPos(elmB);
	var sizeB = lib.dhtml.getSize(elmB);
	var pdB = [lhB[0] + sizeB[0], lhB[1] + sizeB[1]];
	
	if ((pdB[1] < lhA[1]) || (lhB[1] > pdA[1]) || (pdB[0] < lhA[0]) || (lhB[0] > pdA[0])) {
		result = false;
	}

	return result;
};

lib.dhtml.center = function (elm, forceCenter) {
	// centers the block on the screen.
	// if the block is bigger than the page, it is positioned to [0, 0] unless forceCenter is true
	var view =  lib.dhtml.getViewSize();
	var pos  =  lib.dhtml.getViewPos();
	var size =  lib.dhtml.getSize(elm);
	
	var newX = Math.floor((view[0] - size[0]) / 2) + pos[0];
	var newY = Math.floor((view[1] - size[1]) / 2) + pos[1];
	
	if (!forceCenter) {
		if (newX < 0) {
			newX = 0;
		}
		if (newY < 0) {
			newY = 0;
		}
	}
	return lib.dhtml.setPos(elm, [newX, newY]);
};

lib.dhtml._getOffsetModifier = function (elm) {
	var result = [0, 0];
	var currentElm;
	if (elm.offsetParent) {
		currentElm = elm;
		while (currentElm.offsetParent) {
			currentElm = currentElm.offsetParent;
			result[0] += currentElm.offsetLeft;
			result[1] += currentElm.offsetTop;
		}
	} else if (typeof elm.x != "undefined") {
		result[0] = elm.x;
		result[1] = elm.y;
	}
	return result;
};
